import Control.Concurrent.STM ( atomically )
import Control.Concurrent.STM qualified as STM
    ( atomically,
      STM,
      dupTChan,
      newBroadcastTChanIO,
      readTChan,
      writeTChan,
      TChan )
import Control.Lens
    ( (&), (^?), to, (<<%=), (%=), makeClassy, Ixed(ix) )
import Control.Lens qualified as L ()
import Control.Monad.Reader
    ( (<=<), MonadIO(..), MonadTrans(..), MonadReader, ReaderT(..) )
import Control.Monad.State ( MonadState, StateT(runStateT) )
import Control.Monad.Writer.Strict
    ( MonadWriter(writer), runWriter, Writer )
import Data.Aeson ( decode, encode )
import Data.Aeson.TH ()
import Data.ByteString.Lazy qualified as BL ( ByteString )
import Data.HashMap.Monoidal ()
import Data.HashMap.Strict ()
import Data.HashMap.Strict qualified as HM ()
import Data.Hashable ( Hashable )
import Data.IORef ( newIORef, readIORef, writeIORef )
import Data.IntMap.Monoidal.Strict ( MonoidalIntMap )
import Data.IntMap.Monoidal.Strict qualified as MonoidalIntMap
    ( singleton, MonoidalIntMap(getMonoidalIntMap) )
import Data.Semigroup.Monad ( Action(..) )
import Data.Text qualified as T ( unpack, Text )
import Data.Text.Lazy qualified as TL ()
import Debug.Trace ()
import Import ( tshow )
import LiveView.Html
    ( Hsaction, toSplitText, diffHtml, makeHsaction )
import LiveView.Serving
    ( ActionCall(_action, _payload), Clock(Clock), mergePar )
import Lucid ( Html )
import Lucid qualified as L ( HtmlT )
import Lucid.Base qualified as L ( commuteHtmlT )
import StmContainers.Map qualified as StmMap
    ( delete, insert, lookup, newIO, Map )
import Streaming ( Of, Stream )
import Streaming.Prelude qualified as S ( map, mapM_, untilLeft )
import Text.Read ( readMaybe )
import Data.Composition ( (.:) )
